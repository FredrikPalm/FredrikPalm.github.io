var world;
var areas;// = {"totalAmount":0,"mountain":0,"water":0,"grass":0,"forest":0,"sand":0,"id":0};
var selected;
var idCounter=0;
var depthMax = 20;
var seed;
var	resizable = false;
var h; //window height
var w; //window width
var m;  //m is the mersenne twister used to generate random numbers
var maxHeight; //no longer used
var minHeight;
var mode; //dynasty or colonization
var filter;
var center;
var localMapTileSize;
var year = 0;
var yearInc = 1;
var seasons = ["Spring", "Summer", "Fall", "Winter"];
var season = 0;
var uiClick;
var uiHover;
var uiHoverEnd;
var uiDblClick;
var zoomState = false;
var zoomLevel = 1;
var zoomMax = 8;
var zoomMin = 1;
var xScroll = 0;
var yScroll = 0;
var dx = 0;
var dy = 0;
var scrollRate = 25;
var debug;



var tileTypes = ["grass","water","forest","mountain", "settlement"];
var mapRules = {"water":{"freq":0.20,"size":{"min":0.05,"max":0.08}}, 
				"mountain":{"freq":0.1,"size":{"min":0.005,"max":0.02}}, 
				"forest":{"freq":0.25,"size":{"min":0.05,"max":0.25}},
				"settlement":{"freq":0,"size":{"min":0,"max":0}}};		

/*TODO 

		THIS TEXT IS OVER A YEAR OLD: ALL NEW CONTENT IN OTHER FILES 


		Develop basic game functionality
		World editor
		Events
		Person viewer		
		Set and display traits
		Family Trees
		
		UI:
			
			UI adapts to screen size
			Use repaint to draw filters
			Several filters simultaneously	
			
		iPad:

			Scrolling and Zooming
			
		A typical turn:
		
		 Read news
		 Deal with events
		  * Decide what characters to leave in charge of what
		 Identify a goal
		  * Capture new areas
		  * Build new alliances
		  * etc
		 Work towards goal
		  * Build wealth
		  * Develop owned lands
		  * Send characters as diplomats to other factions
		 End turn
		
		Features:
		 * Autogenerated continent sized world
		 * World is automatically populated with people and resources
		 * Two views: A "world" map and a "local" map.
		 * Cities, roads and settlements develop independently of player
		 * Player control a family and its allies through one character, the head of the dynasty.
		 * People have attributes and genetics
		 * Seasons
		 * Markets, "factories" and storehouses are used to build wealth 
		 * Random events
		 
		Ideas:
		
		 The player only controls one character, but the other family members may still act.
		 The player may give these characters resposibilities according to their skill sets. For instance:
		  * Head of Economy 	-	make sure that factories are efficient  
		  * Head of Diplomacy 	-	make sure that alliances are uphold
		  * Head of Defence, etc
		 The player can divide the empire into several sections, each with their own managements.
		 Could even use knights, squires and the like, each with their own responsibilities and rights.
		
		Spaces
		Add Resources
		Calculate Wealth, Fertility (using Proximity to water/land and other fertile/rich tiles)
		Calculate water volume (tiles connected as ocean), start with tiles surrounded by water.
		Do the same for forest, mountains etc.
		Make attempt at rivers
		Place population
		TileView
		Recipes
*/

/*
		Raw Resources:
			Grass: Wheat, Sheep, Horse, Cows,   
			Forest: Wood, Pigs, 
			Water: Fish, Sand, 
			Mountain: Stone, Iron, Copper, Coal
		Produce:
			Bread (wheat), Wool (sheep), Leather (cow), Clothes (wool, leather), Cooked Fish (fish), Meat (sheep, cows, pigs), 
			Cooked Meat (meat), Wooden Plank (wood), Weaponry (wood, stone, iron), Boat (wood, iron), Tamed Horse (horse), 
		Random Events:
			Disease spread, Dynasty Character dies, is born, is wounded, struck with disease, married etc., Flooding, Volcano eruption, 
			Assassination, Army Draft, War, Various religious events, various political events, 
		
			
*/

/*Move these*/
function trim(str) { //use $.trim(String)
    str.replace(/^\s*/, '').replace(/\s*$/, ''); 
   return str;
} 

function generateUniqueId() { //returns unique nr. useful when waiting for information from ajax-requests.
    return idCounter++;
}

function member(element, array){
	for(var i = 0; i < array.length; i++){
		if(element == array[i]){
			return i;	
		}
	}
	return -1;
}

function getUrlVar(afterChar) {
	afterChar = (afterChar == undefined) ? "#" : afterChar;
	var index = window.location.href.indexOf(afterChar);
    if (index != -1) {
        return window.location.href.substr(index + afterChar.length);
    } else {
        return "";
    }
}

function timeDiff(t0,t1,message){
	console.log(message + (t0.getTime() - t1.getTime()));
}

function plusMinus(value, diff){
	return random(value-diff,value+diff);
}

function random(min,max){
	if(max == undefined){
		max = min;
		min = 0;
	}
	min = Math.ceil(min);
	max = Math.floor(max);
	if(max < min){
		var swap = max;
		max = min;
		min = swap;
	}
	var res = Math.round(m.random()*(max-min)+min);
	return res;
}

function delay(millis) 
{
	var date = new Date();
	var curDate = null;
	do { curDate = new Date(); } 
	while(curDate-date < millis);
} 

/*
		CLASSES

*/

function Resource(name, value, type, areaType, chance, foodValue, drinkValue)
{
	this.name = name;
	this.value = value;
	this.tileType = type;
	this.areaType = areaType;
	this.chance = chance;
	this.foodValue = foodValue;
	this.drinkValue = drinkValue;
}

function Tile(gP, type, neighbours) {
	this.globalPosition = gP; // position in world
	this.localPosition; // position on screen. null if not in view
	this.type = type; // grass, forest, mountain, water
//	this.neighbours = neighbours; // tiles surrounding this one
	this.spaces = []; // subtiles (3x3)
	this.selected = false; // whether the tile is currently selected or not
	this.field = null; //the lake, mountain range, forest or grassland this tile is a part of (if any)
	this.resources =  [];
	this.baseValue = 0;
	this.value = 0;
	this.population = 0;
	this.people = [];
	this.community = null;//deprecated
	this.borders = null;
	this.depth;
	this.height;
}

function Area(){
	this.tiles;
	this.type;
	this.id;
	this.name;
	this.add = function(tile){
		this.tiles.push(tile);
		tile.field = this.id;
	}
	this.append = function(area){
		/*This can probably be improved*/
		for(var i = 0; i < area.tiles.length; i++)
		{
			this.add(area.tiles[i]);
		}
		areas['totalAmount'] = areas['totalAmount'] - 1;
		areas[area.type] = areas[area.type] - 1;
		delete areas[area.id];
	};
}

function City(){ //"extends" Area
	this.name;
	this.population;
	this.resources;
	this.value;
	this.location;
	this.people;
}

function World(){
	this.tiles;
	this.sizeX;
	this.sizeY;
	this.tileSize;
	this.dynasty;
	this.options;
}

function rebuild(){
	/*
	 *	Use this function when loading a game
	 */ 
}
var lastSeason = season;
function getColorForTile(tile){
	var type = tile.type;
	var r,g,b;
	/*if(season == lastSeason && tile.color != undefined){
		return tile.color;
	}*/
	var seasonT = seasons[season];
	if(type == "water"){
		if(seasonT == "Winter"){
			r = 180 - (tile.depth-1)*8;
			g = 180 - (tile.depth-1)*8;
			b = 200 - (tile.depth-1)*2;
			if(b < 150) b = 150;	
		}
		else if(seasonT == "Spring"){
			var c = (tile.depth-1)*3;
			r = 10 - c;
			g = 120 - c;
			b = 255 - c;
		}
		else{
		r = 0;
		g = 0;
		b = 255 - (tile.depth-1)*10;
		if(b < 100) b = 100;
		}
		//return "rgb("+r+","+g+","+b+")";	
	}
	else if(!!tile.road){
		r = random(180,250); g = random(180,250); b = random(180,223);
	}
	else if(type == "grass"){
		var c = 10 + 2*(tile.depth);
		if(c > 200) c = 200;
		if(seasonT == "Winter"){
			r = Math.round(70+1.2*c);
			g = Math.round((153+c/2));
			b = (70+c);
		}
		else if(seasonT == "Spring"){
			r = Math.round(10+1.2*c);
			g = Math.round((133+c/2));
			b = (10+1.3*c);
		}
		else if(seasonT == "Fall"){
			r = Math.round(80+1.2*c);
			g = Math.round((133+c/2));
			b = (5+1.3*c);
		}
		else{
			r = Math.round(10+2*c);
			g = Math.round((133+c/2));
			b = (10+c);
		}
		//return "rgb("+r+","+g+","+b+")";
	}
	else if(type == "mountain"){
		var c = 150 + tile.depth*14;
		if(seasonT == "Winter"){
			r = 1.1*(c+10);
			g = 1.1*(c+10);
			b = Math.round(1.2*c+20);
		}
		else{
			r = c;
			g = c;
			b = Math.round(1.1*c);
		}
	}
	else if(type == "sand"){
		r = 255;
		g = 255;
		b = 9*16;
		//return "#FF9";	
	}
	else if(type == "river"){
		//return "rgb(50,50,255)";
	}
	else if(type == "settlement"){
		r = random(80,152);
		g = 54;
		b = 51;
	}
	else{ //forest
	
		var c = 2*tile.depth;
		if(seasonT == "Winter"){
			r = 0;
			g = (100-c);
			b = (50-c);
		}
		else if(seasonT == "Fall"){
			r = 30;
			g = (110-c);
			b = (20);
		}
		else{
			r = 0;
			g = (96-c);
			b = (48-c);
		}
		//return "rgb(0,"+g+","+b+")";////"#063"; //forest
	} 
	
	if(r < 0) r = 0; if(r > 255) r = 255; if(g < 0) g = 0; if(g > 255) g = 255; if(b < 0) b = 0; if(b > 255) b = 255;
	//tile.color = "rgb("+Math.round(r)+","+Math.round(g)+","+Math.round(b)+")";
	return {"r":plusMinus(r,3),"b":plusMinus(b,3),"g":plusMinus(g,3)};
	return tile.color;
	
}

function getColorFromType(type){
	if(type == "water"){
		return "blue";	
	}
	else if(type == "grass"){
		return "green";	
	}
	else if(type == "mountain"){
		return "#c4c4cA";
	}
	else if(type == "sand"){
		return "#FF9";	
	}
	else if(type == "settlement"){
		return "rgb(92,64,51)";
	}
	else return "#063"; //forest
}

function resourceInfo(tile,resource)
{
	if(tile.resources[resource] > 0)
	{
		var t = $("<div></div>").addClass("resource").addClass(resource)
		.append("<span>"+ resourceData[resource].name +"</span>")
		.append("<div>"+ tile.resources[resource] + "</div>");
		return t;
	}
	else
	{
		return "";
	}
}

function fillActionMenu(tile){
	if(tile != undefined){
		$("#tileActions").append($("<div>").text("No actions available"));
		if(tile.type == "grass"){
			//build stuff!
			$("#tileActions").empty().append($("<div>").text("Start construction"));
		}
		else if(tile.type == "forest"){
			$("#tileActions").empty().append($("<div>").text("Send hunters or gatherers"));
		}
		else if(tile.type == "mountain"){
			//do prospecting
		}
		else if(tile.type == "water"){
			//fishing
		}
		
	}
	//$("#actionMenu").append($("<div>").text("Test"));
}
/*
function actionMenu(){
	var menu = $("<div>").addClass("menues").attr("id","actionMenu").css({"position":"absolute", "bottom":0,"left":0,"height":"33%","width":"20%","z-index":8});
	menu.append($("<div>").text("Available Actions:"));
	$("body").append(menu);
	fillActionMenu();
}
*/
function updateTileInfo(tile)
{
	/*Check if tile is owned*/
	/*If owned by someone else, hide certain information*/
	/*If owned by player, enable options*/
	/*If there's a factory constructed, show factory info*/
	$("#tileInfo .type").text(tile.type[0].toUpperCase() + tile.type.substr(1) + " Tile");
	$("#tileResources").empty();
	
	var keys = Object.keys(tile.resources);
	for(var i = keys.length;i--;) 
	{
		$("#tileResources").append(resourceInfo(tile,keys[i]));
	}
	var population = tile.population;
	var value = tile.value;
	var id = "ID: " + tile.globalPosition.x + ", " + tile.globalPosition.y;
	if(tile.community != null){
		var city = tile.field;
		city = areas[city];
		city = generateCity(city);
		population = city.population;
		value = city.value;
		id = "City";
	}
	$("#tileValue").text(id + ". Tile Value: " + value);
	$("#tilePopulation").text("Tile Population: " + population);
	/*TODO rethink communities*/

	if(false && tile.community != null)
	{
		if(tile.community.globalPosition != undefined){ //tile is part of another tile's community
			 changeOverlayCanvas(world.sizeX,world.sizeY,tileSize,function(x,y){
			 	if(world.tiles[x][y].community == null) return "rgba(0,0,0,0)";
			 	if(world.tiles[x][y].community.globalPosition == tile.community.globalPosition 
			 	|| world.tiles[x][y].globalPosition == tile.community.globalPosition){
			 		return "rgba(100,200,100,0.6)";
			 	}
			 	else{
			 		return "rgba(0,0,0,0)"
			 	}
			 });
		}
		else{ //tile is capital of a community
			/* use tile.community array. No need to redraw entire world */
			changeOverlayCanvas(world.sizeX,world.sizeY,tileSize,function(x,y){
				
			 	if(world.tiles[x][y].community == null) return "rgba(0,0,0,0)";
			 	if(world.tiles[x][y].community.globalPosition == tile.community.globalPosition 
			 	|| world.tiles[x][y].globalPosition == tile.community.globalPosition){
			 		return "rgba(100,200,100,0.6)";
			 	}
			 	else{
			 		return "rgba(0,0,0,0)"
			 	}
			 });
		}
	}
	$("#tileActions").empty();
	fillActionMenu(tile);
	$("#tileInfo").removeClass("hidden").show();
}

function tileClick(evt){ /*Click handler for svg. Deprecated*/
	tileClicked(getTileFromId(evt.target.id));
}

function clearCanvas(canvas, x,y,w,h){
	var ctx = canvas.getContext("2d");
	x = (x == undefined) ? 0 : x;
 	y = (y == undefined) ? 0 : y;
 	w = (w == undefined) ? canvas.width : w;
	h = (h == undefined) ? canvas.height : h;
	ctx.clearRect(x,y,w,h);
}

function changeOverlayCanvas(sizeX,sizeY,sce,func,clear)
{ //use repaint
 sizeX = (sizeX == undefined) ? world.sizeX : sizeX;
 sizeY = (sizeY == undefined) ? world.sizeY : sizeY;
 //scale = (scale == undefined) ? tileSize : scale;
 clear = (clear == undefined) ? false : clear;
 var i = 0;
 var overlay = $("#overlay")[0];
 if(clear){ 
	clearCanvas(overlay);
 }
 var ctx = overlay.getContext("2d");
 for(var y = 0; y < sizeY-1; y += 1){
	 for(var x = 0; x < sizeX-1; x += 1){
		var color = func(x,y);
		i++;
		ctx.fillStyle = color; 
		ctx.strokeStyle = ctx.fillStyle;
		ctx.beginPath();
		ctx.rect(x*scale,y*scale,scale,scale);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	 }
 }
}

function changeOverlay(svg, sizeX, sizeY, scale, func)
{
 changeOverlayCanvas(sizeX,sizeY,scale,func);
 return;
 sizeX = (sizeX == undefined) ? world.sizeX : sizeX;
 sizeY = (sizeY == undefined) ? world.sizeY : sizeY;
 scale = (scale == undefined) ? 4 : scale;
 var color;
 
 arrayT = $("rect[type='overlay']");

 for(var y = 0; y < sizeY-1; y += 1){
	 for(var x = 0; x < sizeX-1; x += 1){
		color = func(x,y);
		var t = (sizeX-1)*y + x;
		if(arrayT[t].id != x+","+y)
			alert(arrayT[t].id +"!= "+x+","+y);
		$(arrayT[t]).attr('fill',color);
		
		//$('rect[id="'+x+','+y+'"][type="overlay"]').attr('fill', color);
	 }
 }
}

//useful zoomlevels: scale = 4 (entire world), scale = 20 (zoomlevel = 5)
var scale;
var fog = false;
var range = 100;
function drawSingleTile(worldToDraw,x,y,style){
	worldToDraw = (worldToDraw == undefined) ? world : worldToDraw;
	if(worldToDraw.tiles[x][y] == undefined){
		return;
	}
	if(style != undefined){
		cctx.fillStyle = style["fillStyle"];
		cctx.strokeStyle = style["strokeStyle"];
	}
	else{
		var c = getColorForTile(worldToDraw.tiles[x][y]);
		cctx.fillStyle = getColorString(c.r,c.g,c.b,1); 
		cctx.strokeStyle = "rgba(0,0,0,0.04)";
		if(worldToDraw.tiles[x][y].selected){
			cctx.strokeStyle = "rgb(255,255,0)";
		}
	}
	var xStart = x*scale - xScroll;
	var yStart = y*scale - yScroll;
	var xEnd = (x+1)*(scale) - xScroll;
	var yEnd = (y+1)*(scale) - yScroll;
	var tileWidth = scale-0.001;
	var tileHeight = scale-0.001;
	if(xStart < 0){ tileWidth += xStart; xStart = 0; }
	if(yStart < 0){ tileHeight += yStart; yStart = 0; }
	if(xEnd > w*2){ tileWidth -= xEnd-w; }
	if(yEnd > h*2){ tileHeight -= yEnd-h; }

	//ctx.beginPath();
	cctx.lineWidth = 0;
	//range = 100;
	
	
	cctx.fillRect(xStart,yStart,tileWidth, tileHeight);
	cctx.strokeRect(xStart+2,yStart+2,tileWidth-2, tileHeight-2);
	
	var sourceX,sourceY,distance,inrange;
	if(fog){
		sourceX = world.dynasty.root.location.globalPosition.x;
		sourceY = world.dynasty.root.location.globalPosition.y
		distance = Math.sqrt(Math.pow(sourceX-x,2) + Math.pow(sourceY-y,2));
		
		inrange = distance < range;
		if(!inrange){
		if(distance > 100){
			distance = 100;
		}
		cctx.fillStyle = cctx.strokeStyle = "rgba(0,0,0,"+distance/100+")";
		cctx.fillRect(xStart,yStart,tileWidth, tileHeight);
		cctx.strokeRect(xStart+2,yStart+2,tileWidth-2, tileHeight-2);
		}
	}
	//draw borders
	//draw resources!
	/*if(world.tiles[x][y].resources != undefined && world.tiles[x][y].resources["pigs"] != undefined){
		cctx.fillStyle = "pink";
		cctx.fillRect(xStart + x%(tileWidth-1), yStart + y%(tileHeight-1),1,1);
	}*/
	if((!fog || inrange) && worldToDraw.tiles[x][y].type == "settlement" && worldToDraw.tiles[x][y].borders != null){
		cctx.fillStyle = "gray";
		for(var i = 0; i < worldToDraw.tiles[x][y].borders.length; i++){
			var border = worldToDraw.tiles[x][y].borders[i];
			if(border == "left"){
				cctx.fillRect(xStart,yStart,2,tileHeight);
			}
			else if(border == "right"){
				cctx.fillRect(xStart+tileWidth-2,yStart,2,tileHeight);
			}
			else if(border == "above"){
				cctx.fillRect(xStart,yStart,tileWidth,2);
			}
			else if(border == "below"){
				cctx.fillRect(xStart, yStart+tileHeight-2,tileWidth,2);
			}
		}
	}
	
	//ctx.rect(xStart,yStart,tileWidth,tileHeight);
	//ctx.closePath();
	//ctx.fill();
	//ctx.stroke();
}

var canvas;
var cctx;

function benchMark(){
	for(var i = 0; i < 10; i++){
		repaint2();
	}
}

function repaint2(worldToDraw){
	processingInstance.redraw();
	return;
	worldToDraw = (worldToDraw == undefined) ? world : worldToDraw;
	var t1 = new Date();
	canvas = $("#canvas")[0];
	cctx = canvas.getContext("2d");
	/*scale = world.tileSize;
	if(zoomState){
		scale *= zoomLevel;
	}*/
	if(scale == worldToDraw.tileSize){//else{
		xScroll = 0;
		yScroll = 0;
	}
	var xTilesOnScreen = Math.ceil(w / scale);
	var yTilesOnScreen = Math.ceil(h / scale);		
	var xTileScroll = Math.floor(xScroll / scale);
	var yTileScroll = Math.floor(yScroll / scale);
	for(var x = xTileScroll; x <= xTileScroll+xTilesOnScreen; x++){
		for(var y = yTileScroll; y <= yTileScroll+yTilesOnScreen; y++){
				if(x < 0 || x >= worldToDraw.sizeX || y < 0 || y >= worldToDraw.sizeY){	
					continue;
				}
				drawSingleTile(worldToDraw,x,y);
			}
		}
	var t2 = new Date();
	timeDiff(t2,t1,"Canvas: Drawing world took ");
}


var resolution = 1;
function sketchProc(processing) {
   	// Override draw function, by default it will be called 60 times per second
	processing.setup = function(){
		processing.size(window.w,window.h, processing.P2D);
		processing.noLoop();
	}
	processing.draw = function() {
 
    function drawTile(tile) {
       	if(tile == undefined) return;
       	var x = tile.globalPosition.x;
       	var y = tile.globalPosition.y;
		var xStart = x;//*scale - xScroll;
		var yStart = y;//*scale - yScroll;
		var xEnd = (x+resolution);//*(scale) - xScroll;
		var yEnd = (y+resolution);//*(scale) - yScroll;
		var tileWidth = scale * resolution;//-0.001;
		var tileHeight = scale * resolution;//-0.001;
		if(xStart < 0){ tileWidth += xStart; xStart = 0; }
		if(yStart < 0){ tileHeight += yStart; yStart = 0; }
		if(xEnd > w*2){ tileWidth -= xEnd-w; }
		if(yEnd > h*2){ tileHeight -= yEnd-h; }
		var color = getColorForTile(tile);
		processing.fill(color.r, color.g, color.b);	
		processing.rect(xStart,yStart,tileWidth,tileHeight);
		//drawImage
		//cctx.strokeRect(xStart+2,yStart+2,tileWidth-2, tileHeight-2);
    }
 	
    // erase background
    //processing.background(224);
 	processing.noStroke();
	if(world == undefined) return;
	var t1 = new Date();
	if(scale == world.tileSize){
		xScroll = 0;
		yScroll = 0;
	}

	processing.translate(-xScroll,-yScroll);
	processing.scale(scale);
	var xTilesOnScreen = Math.ceil(w / scale);
	var yTilesOnScreen = Math.ceil(h / scale);		
	var xTileScroll = Math.floor(xScroll / scale);
	var yTileScroll = Math.floor(yScroll / scale);
	for(var x = xTileScroll; x <= xTileScroll+xTilesOnScreen; x+=resolution){
		for(var y = yTileScroll; y <= yTileScroll+yTilesOnScreen; y+=resolution){
				if(x < 0 || x >= world.sizeX || y < 0 || y >= world.sizeY){	
					continue;
				}
				drawTile(world.tiles[x][y]);
			}
		}
	var t2 = new Date();
	timeDiff(t2,t1,"PROCESSING.js: Drawing world took ");
   	};
}
var canvas;
var processingInstance;

function drawWorld3(worldToDraw,sizeX,sizeY,scale)
{
	$("#newPlayer").empty();
	canvas = document.createElement("canvas");
	var overlay = document.createElement("canvas");
	overlay.id = "overlay";
	canvas.id = "canvas";
	overlay.width = canvas.width = window.innerWidth;
    overlay.height = canvas.height = window.innerHeight;
	$("#newPlayer").append(overlay).append(canvas);
 
 	// attaching the sketchProc function to the canvas
	processingInstance = new Processing(canvas, sketchProc);
	//initGL();

	//repaint2(worldToDraw);
}

function fetchRandomName(gender)
{
	/*This is far too slow. Need an internal resource to fetch from. Not allowed to use behindthename's db anyways*/
	gender = (gender == undefined) ? "m" : gender;
	var a = [];
	$.get("http://www.behindthename.com/php/browse.php?type_gender=1&operator_gender=&value_gender[]=masculine&type_usage=1&operator_usage=&value_usage[]=french&page=2", function(data)
	{
		t = $(data.responseText);
		$("#temp").html(data.responseText);
		$("#temp").html($("#temp .body"));
		look2 = $("#temp div strong a:first-child").each(function(i){
			var name = $(this).text();
			name = name.replace(/\([0-9]\)/g,"");
			name = name.toLowerCase();
			name = name[0].toUpperCase() + name.substr(1);
			name = $.trim(name);
			a.push(name);
		});
		$("#temp").removeClass("hidden").empty();
		$(".window").addClass("hidden");
		$("#temp").append($("<textarea></textarea>").css("background-color","black").attr("id","temp2").attr("cols",1).attr("rows",a.length));
		for(var i = 0; i < a.length; i++){
			$("#temp2").text($("#temp2").text() + a[i] + "\n");
		}
	});
}

function generateResourcesforTile(type, areaType)
{
	var res = [];
	var keys = Object.keys(resourceData);
	for(var i = keys.length;i--;) 
	{
		if(resourceData[keys[i]].tileType != type) continue;
		if(resourceData[keys[i]].areaType != areaType && resourceData[keys[i]].areaType != 'any') continue;
		var r = random(1000);
		if(r <= resourceData[keys[i]].chance*10)
		{
			res[keys[i]] = random(10);
		}
	}
	return res;
}



/*		GENERATE RESOURCES
 *
 *	List of naturally occurring resources: 
 *   Grassland: Cow (shallow), Sheep, Horse (deep), Wheat
 *   Mountain:  Stone, Iron (deep), Copper (deep), Coal (deep) 
 *   Forest: 	Wood (deep), Pigs (shallow)
 *	 Water:		Fish, Drinking water (shallow)
 *	
 */
function generateResources(){
	resourceData = 
	{
	/*  variable, 			Name, Value, TileType, AreaType, Chance of Occuring, Foodvalue, Drinkvalue, Depletion   */
		'cow':new Resource("Cow", 80, 'grass', 'shallow', 5, 1000, 100),
		'sheep':new Resource("Sheep", 60, 'grass', 'any', 2, 400, 0),
		'horse':new Resource("Horse",70, 'grass', 'deep', 1, 200, 0),
		'wheat':new Resource("Wheat",50, 'grass', 'any', 10, 500, 0),
		'stone':new Resource("Stone",10, 'mountain', 'any', 100, 0, 0),
		'iron':new Resource("Iron",1000, 'mountain', 'any', 0.15, 0, 0),
		'copper':new Resource("Copper",700, 'mountain', 'any', 0.20, 0, 0),
		'coal':new Resource("Coal",200, 'mountain', 'any', 2, 0, 0),
		'wood':new Resource("Wood",10, 'forest', 'any', 100, 0, 0),
		'pigs':new Resource("Pigs",50, 'forest', 'any', 3, 800, 0),
		'fish':new Resource("Fish",10, 'water', 'any', 10, 400, 0),
		'dwater':new Resource("Drinking Water",1, 'water', 'shallow', 100, 0, 1000),
		'sand':new Resource("Sand",1,'sand','any',100, 0, 0)
	}
	var tiles = world.tiles;
	var max = 0;
	var min = 100;
	for(var x = 0; x < world.sizeX; x++)
	{
		for(var y = 0; y < world.sizeY; y++)
		{
			var tile = tiles[x][y];
			var type = tile.type;
			var vicinity = [];
			var sameType = 0;
			var types = {grass:0, water:0, mountain:0, forest:0, sand:0};
			var shallow = true;
			var count = 0;
			for(nX = -2; nX < 3; nX++)
			{
				for(nY = 2; nY > -3; nY--)
				{ 	
					
					cX = x + nX;
					cY = y + nY;
					if((nY == 0 && nX == 0) || cX < 0 || cY < 0 || cX >= world.sizeX || cY >= world.sizeY){
						continue; //out of bounds
					}
					else{
						count++;
						vicinity.push(tiles[cX][cY]);
						var nType = tiles[cX][cY].type;
						if(nType == tile.type){
							sameType++;
						}
						types[nType]++;
					}
				}
			}
			if(count > max) max = count;
			if(count < min) min = count;
			if(sameType < 24){
			
				if(type == "grass")
				{
					if(types['water'] + types['sand'] > 1)
					{
						//fertile
						//randomly add wheat, rice, pigs etc
						tile.resources = generateResourcesforTile(type,'shallow');
					}
				}					
				else
				{
					tile.resources = generateResourcesforTile(type,'shallow');
				}
			}
			else
			{
				tile.resources = generateResourcesforTile(type,'deep');
			}
		tiles[x][y] = tile;	
		}
	}
}

function resourceValues(resources)
{
	var res = 0;
	var keys = Object.keys(resources);
	for(var i = keys.length;i--;) 
	{
		if(resourceData[keys[i]] == undefined) continue;
		res += resources[keys[i]]*resourceData[keys[i]].value;
	}
	return res;
}

function determineValue(){
	for(var x = 0; x < world.sizeX; x++){
		for(var y = 0; y < world.sizeY; y++){
			var tile = world.tiles[x][y];
			var value = 100;
			value += resourceValues(tile.resources);
			tile.value = value;
			tile.baseValue = value;
			world.tiles[x][y] = tile;
			/*value =+ tile.vicinity.resources / 100;
			if(tile.type == "grass"){
				value = (fertile) ? value + 100 : value - 100;	
			}*/
			//if tile is valuable
			//for each neighbour, increase value by 50
		}
	}
	for(var x = 0; x < world.sizeX; x++){
		for(var y = 0; y < world.sizeY; y++){
			var tile = world.tiles[x][y];
			var value = 0;
			for(nX = -2; nX < 3; nX++){
				for(nY = 2; nY > -3; nY--){ 	
					cX = x + nX;
					cY = y + nY;
					if((nY == 0 && nX == 0) || cX < 0 || cY < 0 || cX >= world.sizeX || cY >= world.sizeY){
						continue; //out of bounds
					}
					value += Math.floor(world.tiles[cX][cY].baseValue/5);
				}
			}
			tile.value += value;
			world.tiles[x][y] = tile;
		}
	}
}

/*Generates a smaller world.*/
function generateBattlefield(){
	/*  TODO 
	 * 	 Make sure that it is always possible to place units for both participants
	 *	 Modify world generation to ensure that there are fewer lakes and mountains on battlefields
	 *   Make sure that no unit will be unable to move from one part of the battlefield to another
	 *   Make sure that the size of the battlefield is alright
	 *   Generate battlefield from parts of the world
	 *   Generate unit placement for AI as well as basic pathfinding.
	 */ 
	 
	var bf = new World();
	bf.tileSize = 12;
	var w = $(window).width();
	var h = $(window).height();
	bf.sizeX = w/bf.tileSize;
	bf.sizeY = h/bf.tileSize;
	bf.tiles = generateWorld(bf.sizeX,bf.sizeY);	
	return bf;
}

function print(s)
{
	console.log(s);
}

var riverSources = [];

function measureDepth(worldT, type, heightModeOn){
	worldT = (worldT == undefined) ? world : worldT;
	type = (type == undefined) ? 0 : type;
	heightModeOn = (heightModeOn == undefined) ? false : heightModeOn; 
	for(var x = 0; x < worldT.sizeX; x++){
		for(var y = 0; y < worldT.sizeY; y++){
			var tile = worldT.tiles[x][y];
			borderFound = false;
			if(type == 1 && (tile.type != "water" && tile.type != "mountain")){
				continue;
			}
			if(type == 2 && (tile.type == "water" || tile.type == "mountain")){
				continue;
			}
			var depth = 0;
			var heightSet = false;
			var depthSet = false;
			while(!borderFound){
				var yInc = 1;
				if(depth >= depthMax) {
					borderFound = true;
					break;
				}
				for(nx=-depth;nx<=depth;nx++){
					if(Math.abs(nx) == depth){
						yInc = 1;
					}
					else{
						yInc = 2*depth;
					}
					for(ny=-depth;ny<=depth;ny += yInc){	
						if(Math.abs(nx) == depth || Math.abs(ny) == depth){
							var cx = nx+x;
							var cy = ny+y;
							if(cx > 0 && cx < worldT.sizeX && cy > 0 && cy < worldT.sizeY){
								if(worldT.tiles[cx][cy].type != tile.type){
									if(heightModeOn && type == 2 && !heightSet && worldT.tiles[cx][cy].type == "mountain"){
										tile.height = worldT.tiles[cx][cy].height - 3 - 2*(depth);//-1);
										print("Setting height to " + tile.height + " when  mountain's height is " + worldT.tiles[cx][cy].height);
										if(tile.height < 0) tile.height = 0;
										heightSet = true;
										/*if(tile.heigth < minHeight/2){
											tile.height = Math.ceil(minHeight/2);
										}*/
									}
									else if(heightModeOn && type == 2 && !heightSet && worldT.tiles[cx][cy].type == "water"){
										tile.height =  worldT.tiles[cx][cy].height + 3 + 2*(depth-1);
										if(tile.height > 0) tile.height = 0;
										heightSet = true;
										/*if(tile.heigth > maxHeight/2){
											tile.height = Math.floor(maxHeight/2);
										}*/
									}
									if(tile.type == "grass"){
										borderFound = (worldT.tiles[cx][cy].type == "water");
									}
									else if(tile.type == "forest"){
										if(!depthSet){
											depthSet = true;
											tile.depth = depth-1;
										}
										borderFound = heightSet || !heightModeOn;
									}
									else{
										if(tile.type == "mountain"){
											if(depth == 1 && random(300) > 298){
												riverSources.push({"x":cx,"y":cy});
											}
										}
										borderFound = true;
										break;
									}
								}			
								
							}
							else{
								//borderFound = true;
							}
								
						}
						if(borderFound) break;
					}
					if(borderFound) break;
				}
				depth++;
			}
			if(!depthSet){
			tile.depth = depth-1;
			}
			if(heightModeOn && tile.type == "mountain"){
				tile.height = 30+tile.depth;
				if(maxHeight < tile.height){
					maxHeight = tile.height;
				}
			}
			else if(heightModeOn && tile.type == "water"){
				tile.height = -30-tile.depth;
				if(minHeight > tile.height){
					minHeight = tile.height;
				}
			}
		}
	}
}
var cities;
function checkAreas(worldT){
	areas = {"totalAmount":0,"id":0};
	$.each(tileTypes, function(i,val){
		areas[val] = 0;
	});
	worldT = (worldT == undefined) ? world : worldT;
	for(var x = 0; x < worldT.sizeX; x++){
		for(var y = 0; y < worldT.sizeY; y++){
			var tile = worldT.tiles[x][y];
			for(var nx = -1; nx < 2; nx++){
				for(var ny = -1; ny < 2; ny++){	
					var cx = x+nx;
					var cy = y+ny;
					if((nx == 0 && ny == 0) || (cx > worldT.sizeX-1) || (cx < 0) || (cy > worldT.sizeY-1) || (cy < 0) || tile.type != worldT.tiles[cx][cy].type){
						//add borders
						if(Math.abs(nx) != Math.abs(ny)){
							if(tile.borders == null){
							tile.borders = [];
							}
							switch(nx){
								case -1:
									//add border to the left
									tile.borders.push("left"); //Use enum? (left = 0, right = 1 etc)
									break;
								case 1:
									//add border to the right
									tile.borders.push("right")
									break;
								case 0:
									switch(ny){
										case -1:
											//add border above
											tile.borders.push("above")
											break;
										case 1:
											//add border below
											tile.borders.push("below");
											break;
									}
									break;
							}
						}
					}
					else{
						var nTile = worldT.tiles[cx][cy];
						if(tile.field != null){
							if(nTile.field != null){
								if(tile.field == nTile.field)
								{
									//do nothing
								}
								else{
									//append fields	
									areas[tile.field].append(areas[nTile.field]);
								}
							}
							else{
								//add nTile to tile.field
								areas[tile.field].add(nTile);
							}
						}
						else if(nTile.field != null){
							//add tile to nTile.field
							areas[nTile.field].add(tile);
						}
						else{
							//create new field and add both
							var field = new Area();
							field.id = "a"+areas['id']++;
							field.name = "TEMP " + tile.type.toUpperCase() + "AREA";
							field.tiles = [tile, nTile];
							field.type = tile.type;
							areas[field.id] = field;
							areas['totalAmount'] = areas['totalAmount'] + 1;
							areas[field.type]++
							tile.field = nTile.field = field.id;
						}
					} 
				}
			}
		}
	}
	var keys = Object.keys(areas); 
	cities = [];
	for(var i = 0; i < keys.length; i++){
		if(keys[i][0] == "a" && areas[keys[i]].type != undefined)
		{
			if(areas[keys[i]].type == "settlement"){
				cities.push(areas[keys[i]]);
			}
		}
	}
}

function inBounds(world,x,y){
	return (x >= 0 && x < world.sizeX && y >= 0 && y < world.sizeY);
}

function continueRiverFrom(tile,length,previousTile){
	length = Math.floor(length);
	if(length <= 0) return;
	var height = tile.height;
	var x = tile.globalPosition.x;
	var y = tile.globalPosition.y;
	if(previousTile != undefined){
	var prevX = previousTile.globalPosition.x;
	var prevY = previousTile.globalPosition.y;
	}
	world.tiles[x][y].type = "river";
	var candidates = [];
	for(var nx = -1; nx < 2; nx++){
		for(var ny = -1; ny < 2; ny++){
			var cx = nx+x;
			var cy = ny+y;
			if(inBounds(world,cx,cy) && !(nx == 0 && ny == 0)){
				var nextTile =  world.tiles[cx][cy];
				if(nextTile.height < height && !(cx == prevX && cy == prevY)){
					if(nextTile.type == "water"){
						
					}
					else{
					candidates.push(nextTile);
					}
				}
			}
		}
	}
	if(candidates.length > 1){
		var first = random(0,candidates.length-1);
		if(random(0,100) >90){
			continueRiverFrom(candidates[first], (length)/2-1, tile);
			var second = random(0,candidates.length-1);
			while(second == first){
				second = random(0,candidates.length-1);
			}
			continueRiverFrom(candidates[second], (length)/2-1, tile);
		}
		else{
		continueRiverFrom(candidates[first], length-1, tile);
		}
	}
	else if(candidates.length == 1){
		continueRiverFrom(candidates[0], length-1, tile);
	}
}

function generateRivers(world){
	var sizeX = world.sizeX;
	var sizeY = world.sizeY;
	/*var amountOfRivers = sizeX*sizeY*0.01;
	var riverStartTiles = [];
	for(var i = 0; i < amountOfRivers; i++){
		var x = random(0,sizeX-1);
		var y = random(0,sizeY-1);
		riverStartTiles.push(world.tiles[x][y]);
	}*/
	var mountainAreas = []; //array of all mountain areas
	var amountOfMountains = areas["mountain"];
	if(amountOfMountains == 0) return;//TODO rivers that don't start from mountains
	mountainAreas = [];
	var keys = Object.keys(areas); 
	for(var i = 0; i < keys.length; i++){
		if(keys[i][0] == "a" && areas[keys[i]].type != undefined)
		{
			if(areas[keys[i]].type == "mountain"){
				mountainAreas.push(areas[keys[i]]);
			}
		}
	}
	var amountOfLakes = areas["water"];
	var amountOfRivers = Math.round(amountOfMountains * 1.5);
	
	for(var i = 0; i < amountOfRivers; i++){
		var id = random(0,mountainAreas[i%amountOfMountains].tiles.length-1);
		var currentTile;// = riverStartTiles[i];
		var startTile = currentTile = mountainAreas[i%amountOfMountains].tiles[id];
		var riverLength = random(15,30);
		continueRiverFrom(startTile, riverLength);
		/*for(var k = 0; k < riverLength; k++){ //TODO while loop or recursive. add rivers as we go
			var x = currentTile.globalPosition.x;
			var y = currentTile.globalPosition.y;
			var height = currentTile.height;
			var continueRiver = false;
			var pDx = null;
			var pDy = null;
			for(var nx = -1; nx < 2; nx++){
				for(var ny = -1; ny < 2; ny++){
					var cx = nx+x;
					var cy = ny+y;
					if(inBounds(world,cx,cy) && !(nx == 0 && ny == 0)){
						var nextTile =  world.tiles[cx][cy];
						if(nextTile.height < height || (nextTile.height == height && (nx != pDx || ny != pDy))){
							if(nextTile.type == "water"){
								
							}
							else{
							world.tiles[cx][cy].type = "river";
							currentTile = nextTile;
							pDx = nx;
							pDy = ny;
							continueRiver = true;
							}
						}
					}
					if(continueRiver) break;
				}
				if(continueRiver) break;
			} 
			if(!continueRiver) break;
		}*/
	}
}

function generateWorld(sizeX, sizeY, attempts){
	var attempts = (attempts == undefined) ? 0 : attempts;
	var size = sizeX * sizeY;
	if(attempts > 10){
		A = size/100;
		if(attempts > 100){
			alert("failed to create a decent world");
			return;
		}
	}
	var temp = [];
	
	var randomN;
	var sources = [];
	for(var y = 0; y < sizeY; y++){ //iteration 1
		for(var x = 0; x < sizeX; x++){
			var type = "grass";
			/*randomN = random(0,size);//Math.floor(Math.random()*(size)); //16000
			if(randomN < mapRules["water"]["freq"]*100){
				type = "water";
				sources.push({x:x, y:y, p:randomN});
			}
			else if(randomN < (mapRules["water"]["freq"] + mapRules["forest"]["freq"])*100){
				type = "forest";
				sources.push({x:x, y:y, p:randomN});
			}
			else if(randomN < (mapRules["water"]["freq"] + mapRules["forest"]["freq"] + mapRules["mountain"]["freq"])*100){
				type = "mountain";
				sources.push({x:x, y:y, p:randomN});
			}*/
			if(y == 0){
			temp[x] = [];
			}
			temp[x][y] = new Tile({x:x,y:y}, type, []);
		}
	}
	
	
	var keys = Object.keys(mapRules);
	for(var i = 0; i< tileTypes.length;i++) 
	{
		if(tileTypes[i] == "grass") continue;
		var type = tileTypes[i];
		/*if(mapRules[type]["size"]["max"] > mapRules[type]["freq"]*size){
			mapRules[type]["size"]["max"] = mapRules[type]["freq"]*size;
		}
		if(mapRules[type]["size"]["min"] > mapRules[type]["freq"]*size){
			mapRules[type]["size"]["min"] =  mapRules[type]["freq"]*size
		}*/	
		var averageSize = 1+size*((mapRules[tileTypes[i]]["size"]["min"] + mapRules[tileTypes[i]]["size"]["max"])/2);
		var amount = Math.round((mapRules[tileTypes[i]]["freq"]*size)/averageSize);
		print("amount of " + tileTypes[i] + " sources is " + amount)
		for(var k = 0; k < amount; k++){
			lowestAllowedDistanceST = 50;//size*0.001;
			lowestAllowedDistanceDT = 20;//size*0.0001;
			var stopLooping = false;
			var x,y;
			while(!stopLooping){
				x = random(0,sizeX-1);
				y = random(0,sizeY-1);
				stopLooping = true;
				for(var n = 0; n < sources.length; n++){
					var distance = Math.sqrt(Math.pow(sources[n].x-x,2) + Math.pow(sources[n].y-y,2));
					if(distance < lowestAllowedDistanceST && temp[sources[n].x][sources[n].y].type == tileTypes[i]){
						stopLooping = false;
					}
					else if(distance < lowestAllowedDistanceDT){
						stopLooping = false;
					}
				}
			}
			temp[x][y].type = tileTypes[i];
			sources.push({x:x,y:y});
		}
	}
	if(false && sources.length < 10){ //necessary?
		generateWorld(sizeX, sizeY, attempts + 1); //try again ..
	}
 
	var increment = 1;
	if(sources.length > 1000)
	{
		increment = 1 + Math.round(sources.length / 100);
	}
	waterTiles = 0;
	placed = 0;
	for(var i = 0; i < sources.length; i++){	
		var origin = {x:sources[i].x, y:sources[i].y}
		var direction, x, y;
		x = origin.x;
		y = origin.y;
		var type = temp[origin.x][origin.y].type;
		var amountLeft = random(Math.round(size*mapRules[type]["size"]["min"]),Math.round(size*mapRules[type]["size"]["max"]));
		amountLeft = Math.round(size*((mapRules[type]["size"]["min"] + mapRules[type]["size"]["max"])/2));
		var shouldPlace;
		if(type == "water"){
			waterTiles += amountLeft;
			shouldPlace = amountLeft;
		}
		var errorsInARow = 0;
		while(amountLeft > 1 && errorsInARow < 200){
			if(errorsInARow == -1 && random(0,100) > 75){
				x+= direction;
				y+= direction;
			}
			else{
			direction = random(-1,1);//Math.floor(Math.random()*3) - 1;
			x += direction;
			direction = random(-1,1);//Math.floor(Math.random()*3) - 1;
			y += direction;
			}
			if(x < 0 || x >= world.sizeX || y < 0 || y >= world.sizeY || temp[x][y].type != "grass" ){
				x = origin.x + random(-10,10);
				y = origin.y + random(-10,10);
				//place river from x to origin.x
				
				errorsInARow++;
			}
			else{
				if(random(0,100) > 91){	
					origin.x = x;
					origin.y = y;
					
				}
				temp[x][y].type = type;
				amountLeft--;
				errorsInARow = -1;
			}
		}
		if(type == "water"){
		placed += shouldPlace - amountLeft;
		}
	}
	//	var areaId = areas[type].length;
	//	areas[type].push({id:areaId, tiles:[]});
		/*if(type == "water"){
			if(random(0,11) > 8){//}Math.floor(Math.random()*11) > 8){
				randomN = 300;
			}
			else{
				randomN = 150;
			}
		}
		else if(type == "forest"){
			randomN = 150;
		}
		else if(type == "mountain"){
			randomN = 150;
		}
		for(var k = 0; k < randomN; k++){
			direction = random(-1,1);//Math.floor(Math.random()*3) - 1;
			x = sources[i].x + direction;
			direction = random(-1,1);//Math.floor(Math.random()*3) - 1;
			y = sources[i].y + direction;
			if(x < 0 || x >= sizeX || y < 0 || y >= sizeY){
			 	sources[i].x = origin.x;
				sources[i].y = origin.y;
			}
			else if(temp[x][y].type == type){
				if(type == "mountain" || random(0,16) > 2){//Math.floor(Math.random()*16) > 2){
					sources[i].x = x;	
					sources[i].y = y;
					direction = random(-2,2);//Math.floor(Math.random()*9) - 4;
					x = sources[i].x + direction;
					direction = random(-2,2);//Math.floor(Math.random()*9) - 4;
					y = sources[i].y + direction;
					sources[i].x = x;	
					sources[i].y = y;
			 	}
			 	else{
					sources[i].x = origin.x;
					sources[i].y = origin.y;
			 	}
			}
			else{
				temp[x][y].type = type;
	//			temp[x][y].field = areaId;
	//			areas[type][areaId].tiles.push(temp[x][y]);
			}
		}
	}*/
	
	for(var twice = 0; twice < 3; twice++){
	for(var y = 0; y < sizeY; y++){
		for(var x = 0; x < sizeX; x++){
			//count neighbours
			var tile = temp[x][y];
			var sameType = 0;
			var types = {grass:0, water:0, mountain:0, forest:0, sand:0};
			for(nX = -1; nX < 2; nX++){
				for(nY = 1; nY > -2; nY--){ 		
					cX = x + nX;
					cY = y + nY;
					if((nY == 0 && nX == 0) || cX < 0 || cY < 0 || cX >= sizeX || cY >= sizeY){
						continue; //out of bounds
					}
					else{
					//	tile.neighbours.push(temp[cX][cY]);
						var nType = temp[cX][cY].type
						if(nType == tile.type){
							sameType++;
						}
						types[nType]++;
					}
				}
			}
			if(sameType < 3){
				mostOf = {type:"grass", amount:types['grass']};
				if(types["water"] > mostOf.amount){
					mostOf = {type:"water", amount:types['water']};	
				}
				if(types["mountain"] > mostOf.amount){
					mostOf = {type:"mountain", amount:types['mountain']};	
				}
				if(types["forest"] > mostOf.amount){
					mostOf = {type:"forest", amount:types['forest']};	
				}
				tile.type = mostOf.type;
			}
			if(types['water'] > 2 && tile.type != "water" && (random(5) > 2)){
				tile.type = "sand";	
			}
		}
	}
	}
	
	/*for(var y = 0; y < sizeY; y++){
		for(var x = 0; x < sizeX; x++){
			var tile = temp[x][y];
			//tile.spaces = [];
			for(var i = 0; i < 2; i++){
				for(var k = 0; k < 2; k++){
					if(k == 0){
						tile.spaces[i] = [];
					}
					tile.spaces[i][k] = new Tile();
					if(random(1000) == 898){
						tile.spaces[i][k].type = "water";
					}
					else{
						tile.spaces[i][k].type = tile.type;
					}
				}
			}
		}
	}*/
	
	return temp;
}

function getTileFromId(id){
	var x = id.substring(0, id.indexOf(","));
	var y = id.substring(id.indexOf(",") + 1);
	return world.tiles[x][y];
}

function tileClicked(worldTile)
{
	/*Zoom in if in world map mode*/
	/*if(!mode)
	{
		center = worldTile.globalPosition;
		mode = true;
		drawWorld2($("#newPlayer").svg('get'),world.sizteX, world.sizeY, tileSize);
		return;
	}
	*/
	/*Else, if in local map mode:*/
	updateTileInfo(worldTile);
	$("#tileInfo").show();
	/*Make sure that the info is entirely in view. Move camera so that tile is centered if necessary*/
	//$("#tileInfo").css("left", (worldTile.globalPosition.x+1) * tileSize);
	//$("#tileInfo").css("top", worldTile.globalPosition.y * tileSize - 150);
	
	/*If double click*/
	//tField = areas[worldTile.type][worldTile.field];
	//alert(worldTile.field.tiles.length + " " + worldTile.field.id);
	//tField = areas[worldTile.field];
	var tField = worldTile.field;
	changeOverlayCanvas(world.sizeX,world.sizeY,world.tileSize,function(x,y){
		if(world.tiles[x][y].field == tField && world.tiles[x][y].borders != null){
			return 'rgba(10,10,40,0.3)';
		}
		else return 'rgba(0,0,0,0)';
	}, true);
	return;/*
	if(selected != undefined){
	selected.setAttribute("stroke", selected.getAttribute("fill"));
	}
	selected = tile;	
	tile.setAttribute("stroke", "yellow"); 
	$(tile).addClass("selected");	
	*/
}

function tileClick(evt){
	var tile = evt.target;
	followT = tile;
	tileClicked(getTileFromId(tile.id));
}

function constructEvent(event)
{
	var viewer = $("#eventViewer");
	viewer.append($("<div></div>").text(event.text()));
	viewer.append("<div class='close'>close</div>");
}

function statsScreen()
{
	var viewer = $("#eventViewer");
	viewer.append($("<div></div>").text(nrTiles + " tiles\n"));
	viewer.append("Water:" + (Math.round(100*(types["water"]) / (world.sizeX*world.sizeY))) + "% \n");
	viewer.append("Grass:" + Math.round(100*types["grass"] / (world.sizeX*world.sizeY)) + "% \n");
	viewer.append("Forest:" + Math.round(100*types["forest"] / (world.sizeX*world.sizeY)) + "% \n");
	viewer.append("Mountain:" + Math.round(100*types["mountain"] / (world.sizeX*world.sizeY)) + "% \n");
	viewer.append("<div class='close'>close</div>");
}

function showPerson(person){
	//	__________
	//	|portrait|
	//	|		 |
	//	|________|
	//	FULL NAME
	//
	//but for now...
	return $("<div>").addClass("personName").text(person.fname + " " + person.sname);
}

function constructMenu(menuType)
{
 var menu = $("#MenuDisplay");
 if(menuType == "options")
 {
	var exportGame = $("<div></div>").attr("id","exportGame").addClass("options").text("Export Game");
	var setResolution = $("<div></div>").attr("id","setResolution").addClass("options").text("Set Tile Size");
	var reloadGame = $("<div></div>").attr("id","reloadGame").addClass("options").text("Reload World");
	var battleTest = $("<div></div>").attr("id","battleTest").addClass("options").text("Generate Battlefield");
	menu.append(exportGame).append(reloadGame).append(setResolution).append(battleTest);
 }
 else if(menuType == "dynasty"){
		showDynasty();
		$("#FamilyTree").show();
 }
 else if(menuType == "filter")
 {
	var population = $("<div></div>").attr("id","populationFilter").addClass("filter").text("Show Population");
	var wealth = $("<div></div>").attr("id","wealthFilter").addClass("filter").text("Show Wealth");
	var food = $("<div></div>").attr("id","foodFilter").addClass("filter").text("Show Food");
	var heightMap = $("<div></div>").attr("id","heightMapFilter").addClass("filter").text("Show Height Map");
	menu.append(population).append(wealth).append(heightMap).append(food);
 }
 else if(menuType == "stats")
 {
	var stats = $("<div></div>").attr("id","stats").addClass("stats").text("Stats");
	var famtree = $("<div></div>").attr("id","familytree").addClass("stats").text("Family Tree");
	var reloadGame = $("<div></div>").attr("id","reloadGame").addClass("options").text("Habla habla");
	menu.append(stats).append(famtree).append(reloadGame);
 }
 else if(menuType == "events")
 {
	var event1 = $("<div></div>").attr("id","event1").addClass("event").text("Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.");
	var event2 = $("<div></div>").attr("id","event2").addClass("event").text("Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?");
	menu.append(event1).append(event2);
 }
 menu.append("<div class='close'>close</div>");
}

function zoomInOn(tile,event){
	//var nTileSize = world.tileSize*zoomLevel;
	// 0 <= xScroll (or yScroll) <= 4*w(or h) where the 4 is the zoom amount
	var xShift, yShift;
	if(event.pageX == undefined){
		zoomLevel = event/scale;
		zoomState = true;
		scale = event;
		var xShift = w/2;
		var yShift = h/2;
	}
	else{
		scale = world.tileSize*zoomLevel;
		var xShift = event.pageX;
		var yShift = event.pageY;
	}
	
	xScroll = tile.globalPosition.x*scale - xShift;
	yScroll = tile.globalPosition.y*scale - yShift;

	if(xScroll > (world.sizeX*scale-w)) xScroll = (world.sizeX*scale-w);
	if(xScroll < 0) xScroll = 0;
	if(yScroll > (world.sizeY*scale-h)) yScroll = (world.sizeY*scale-h);
	if(yScroll < 0) yScroll = 0;
	
	repaint2();
}
function keyBindings(){
	$(document).bind('mousewheel', function(e){
		$("#tileInfo").hide();
		if(e.wheelDelta > 0){
			zoomLevel += 1;
		}
		else{
			zoomLevel -= 1;
		}
		//zoomLevel += e.wheelDelta/120;
		if(zoomLevel > zoomMax){
			zoomLevel = zoomMax;
		}
		else if(zoomLevel < zoomMin){
			zoomLevel = zoomMin;
		}
		zoomState = true;
		if(zoomState){
			if(zoomLevel == 1){
				xScroll = 0;
				yScroll = 0;
			}
			zoomInOn(tileFromEvent(e), e);
		}
		else{
			xScroll = 0;
			yScroll = 0;
			repaint2();
		}
	});
	$("#newPlayer").live(uiClick, function(e){
		//$("#tileInfo").hide();
		//zoomState = !zoomState;
		select(tileFromEvent(e));
		
		/*if(zoomState){
			zoomInOn(tileFromEvent(e));
		}
		else{
			xScroll = 0;
			yScroll = 0;
			repaint2();
		}*/
	});
	$(document).delegate("*", 'keydown', function(e){
		switch(e.keyCode){
			case 32:
				zoomState = !zoomState;
				repaint();
				break;
			case 37:
				dx = -1;
				break;
			case 38:
				dy = -1;
				break;
			case 39:
				dx = 1;
				break;
			case 40:
				dy = 1;
				break;
			}
	});
	$(document).delegate("*", 'keyup', function(e){
		switch(e.keyCode){
			case 37:
				dx = 0;
				break;
			case 38:
				dy = 0;
				break;
			case 39:
				dx = 0;
				break;
			case 40:
				dy = 0;
				break;
			}
	});
	$(window).resize(function(e){
		e.preventDefault();
		if(resizable){
		}
		else{
			alert("Please don't resize the window");
			window.resizeTo( w,h )
		}
	});
	$(".header").live(uiClick, function(event){
		if($(this).attr("menuType") != undefined){
			$("#MenuDisplay").empty();
			constructMenu($(this).attr("menuType"));
			$("#MenuDisplay").show().removeClass("hidden");
		}
	});
	$(".close").live(uiClick, function(event){
		$(this).parent().hide();//addClass("hidden");
	});
	$(".event").live(uiClick,function(event)
	{                                  
		/*open event in eventViewer*/
		var top = 0.15*($("body").height());
		var left = 0.15*($("body").width());
		$("#eventViewer").css("top",top).css("left",left).empty().removeClass("hidden");
		constructEvent($(this));
	});
	$("#stats").live(uiClick,function(event)
	{                                  
		/*open stats in eventViewer*/
		var top = 0.15*($("body").height());
		var left = 0.15*($("body").width());
		$("#eventViewer").css("top",top).css("left",left).empty().removeClass("hidden");
		statsScreen();
		
	});
	$("#populationFilter").live(uiClick, function(event){
		filter = !filter;
		if(filter)
		{
			changeOverlay($("#newPlayer").svg('get'),world.sizeX, world.sizeY, tileSize,function(x,y){
				if(world.tiles[x][y].population != 0)
				{
					return 'rgba('+Math.floor(100+155*world.tiles[x][y].population/largestCity)+',75,75,0.5)';
				}
				else{
					return 'rgba(0,0,0,0)';
				}
			});
		}
		else
		{
			changeOverlay($("#newPlayer").svg('get'),world.sizeX, world.sizeY, tileSize,function(x,y){
					return 'rgba(0,0,0,0)';
			});
		}
		//drawWorld2($("#newPlayer").svg('get'),world.sizeX, world.sizeY, tileSize);
	});
	$("#foodFilter").live(uiClick, function(event){
		changeOverlay($("#newPlayer").svg("get"),world.sizeX,world.sizeY,tileSize, function(x,y){
			var depth = world.tiles[x][y].depth;
			return 'rgba('+depth*10+','+depth*10+','+depth*10+',1)';
		});
	});
	$("#heightMapFilter").live(uiClick, function(event){
		changeOverlay($("#newPlayer").svg("get"),world.sizeX,world.sizeY,tileSize, function(x,y){
			var height = world.tiles[x][y].height;
			height += Math.abs(minHeight);
			height /= maxHeight;
			height *= 100;
			height = Math.round(height);
			return 'rgba('+height+','+height+','+height+',1)';
		});
	});
	$("#canvas,#overlay").live(uiClick,function(event)
	{
		tEv = event;
		//id = {x:Math.floor(event.pageX/tileSize),y:Math.floor(event.pageY/tileSize)};
		tileClicked(tileFromEvent(event));
	});
	$("#battleTest").live(uiClick, function(event){
		var bf = generateBattlefield();
		drawWorld3(bf);
	});
	/*$("#DateHeader").hover(
		function () {
			$(this).text("Next Turn");
		}, 
		function () {
			$(this).text("Year " + year);
		});*/
	$("#TurnHeader").live(uiClick, function(event){
		nextTurn();
		updateDateHeader();
	});
}

function nextTurn(){
	season++;
	if(season > 3){
		season = 0;
		year++;
	}
	repaint2();
	//year += yearInc;
	//$("#Loading").show();	
}

function newWorld(res){//deprecated
	alert("Generating new world with more detail, this make take some time");
	h = $(window).height();
	w = $(window).width();
	tileSize = res;
	var sizeX = w/tileSize;
	var sizeY = h/tileSize;
	world = new World();	
	world.tiles = generateWorld(sizeX,sizeY);
	world.sizeX = world.tiles.length;
	world.sizeY = world.tiles[0].length;
	$("#newPlayer").svg('get').clear();
	drawWorld2($("#newPlayer").svg('get'),world.sizeX, world.sizeY, tileSize);
}


function updateDateHeader(){
	$("#DateHeader").text(year+":"+seasons[season]);
}

function loadWorld(location){
	world = new World();
	world = jsonTo(sessionStorage[location]);
	rebuild();
}

function openInitMenu(createWorld){
	$("#NewGameMenu").empty();
	$("#newPlayer").live(uiClick, function(e){}); //this is stupid...
	var quickStart = $("<div>").addClass("selectable").attr("id","quickStart").click( function(e){start();}).text("Start Playing");
	var newGameBtn = $("<div>").addClass("selectable").attr("id", "newGame").click( function (event){newGame();}).text("New Game With Options");
	var continueGameBtn = $("<div>").addClass("selectable").attr("id", "continueGame").click( function (event){continueGame()}).text("Continue Game");
	var loadGameBtn = $("<div>").addClass("selectable").attr("id", "loadGame").click( function(event){loadGame()}).text("Load Game");
	var optionsBtn = $("<div>").addClass("selectable").attr("id", "options").click( function(event){options()}).text("Options");
	$("#NewGameMenu").append(quickStart).append(newGameBtn).append(loadGameBtn).append(optionsBtn);
	if(saveExists()){
		$("#NewGameMenu #newGame").after(continueGameBtn);
	}
	startLoading();
	if(createWorld == undefined || createWorld){
		$.get("scripts/io.js", function(data){ //dumb way of making these functions asynchronous
			if(!saveExists()){
				craftNewWorld();
			}
			else{
				//loadLatestSavedWorld();
			}
		});
	}
	else{
		$("#newPlayer").show();
	}
}

function tileFromEvent(event){
	//TODO doesn't work with zoom and scroll.
	var x = Math.floor(event.pageX/(scale) + xScroll/scale);
	var y = Math.floor(event.pageY/(scale) + yScroll/scale);
	return world.tiles[x][y];
}

function select(tile){
	if(selected != undefined){
		selected.selected = false;
		drawSingleTile(selected.globalPosition.x, selected.globalPosition.y);
	}
	selected = tile;
	tile.selected = true;
	drawSingleTile(tile.globalPosition.x, tile.globalPosition.y, {"fillStyle":getColorForTile(tile),"strokeStyle":"rgb(255,255,0)"});
	//repaint2();
}

function characterGen(){
	var player;
	if(world.dynasty != undefined && world.dynasty.root != undefined){
		player = world.dynasty.root;
	}
	else{
		alert("error");
		//player = new generatePerson();
		//createDynasty(player); //move these to newGame()
		//generateResources();
		//determineValue();
		//generatePopulation();
		//drawWorld3();
	}
	var firstName = $("<input></input>").addClass("nLoc").attr("id", "fNameInput").val(player.fname).change(
		function(){
			world.dynasty.root.fname = $(this).val();
		});
	var lastName = $("<input></input>").addClass("nLoc").attr("id", "lNameInput").val(player.sname).change(
		function(){
			world.dynasty.root.sname = $(this).val();
		});
	var randomFName = $("<div>").addClass("selectable").addClass("nLoc").text("Random First Name").click( function(){$("#fNameInput").val(world.dynasty.root.fname = generateFirstName($("#cGender").text()));});
	var randomLName = $("<div>").addClass("selectable").addClass("nLoc").text("Random Surname").click( function(){$("#lNameInput").val(world.dynasty.root.sname = generateSurName());});
	var genderInput =  $("<span>").text(player.gender).attr("id","cGender");
	var genderChoice = $("<span>").addClass("selectable").text("Switch").click(function(e){
		if($("#cGender").text()=="Male"){world.dynasty.root.gender="Female";$("#cGender").text("Female");}
			else{world.dynasty.root.gender="Male";$("#cGender").text("Male");}
			});
	var genderOptions = $("<div>").addClass("nLoc").append($("<span>").text("Gender: ").append(genderInput).append(genderChoice));
	var traitsSet = $("<div>").addClass("selectable").addClass("nLoc").text("Show and Manipulate Traits");
	var locationSet = $("<div>").addClass("selectable").attr("id","lSet").text("Set Starting Location").click( function(){
		$(this).click( function(){
			$(this).text("Set Starting Location");
			$("#newPlayer").unbind();
			$("#NewGameMenu").draggable('destroy').css({"height":"","left":"","right":"","bottom":0,"right":0});
			$("#Title, .nLoc").show();
		});
		$(this).text("Click on a settlement (orange tiles). Click here to return.").css("font-size","20px");
		$("#NewGameMenu").css("height","10%").draggable();
		$("#Title, .nLoc").hide();
		$("#newPlayer").click( function(e){
			var loc = tileFromEvent(e);
			if(loc.type == "settlement"){
				world.dynasty.root.location = loc;
				movePersonTo(world.dynasty.root,loc);
				select(tileFromEvent(e));
				$("#lSet").text("Click here to accept");
			}
			else{
				alert("Please click on a settlement");
			}
		});
	});
	var startGame = $("<div>").addClass("selectable").addClass("nLoc").text("Start Playing").click( function(){createDynasty(world.dynasty.root);start();});
	var back = $("<div>").addClass("selectable").addClass("nLoc").text("Back to World Creation").click( function(){createDynasty(world.dynasty.root);newGame();});
	$("#NewGameMenu").empty().append(genderOptions).append(firstName).append(lastName).append(randomFName).append(randomLName)
	.append(traitsSet).append(locationSet).append(startGame).append(back);
}

function editWorld(location){
	if(location == undefined){
		location = $("#NewGameMenu");
		
	}
	
	location.show().draggable();
	location.find("*").addClass("temp").addClass("hidden");
	$.each(tileTypes, function(i,val){
		var name = val[0].toUpperCase()+val.substr(1);
		var cssO = {"background-color":getColorFromType(val),"font-size":"20px"}; 
		location.append(
			$("<div>").addClass("rtemp").append($("<span>").addClass("smallSquare").text(name + " Tile").css(cssO))
					  .append($("<span>").addClass("smallSquare").text(name + " Formation").css(cssO)));
	});
	var importWorld = $("<div>").addClass("selectable").addClass("rtemp").text("Import World").click( function(e){alert("...");});
	var exportWorld;
	var blankSlate = $("<div>").addClass("selectable").addClass("rtemp").text("Cover World With Grass").click( function(e){
		//are you sure?
		for(var x=0;x<world.sizeX;x++){
			for(var y=0;y<world.sizeY;y++){
				world.tiles[x][y].type = "grass";
				world.tiles[x][y].depth = 0;
			}
		}
		repaint2();
	});
	var done = $("<div>").addClass("selectable").addClass("rtemp").text("Done").click( function(e){
	location.find(".rtemp").remove();
	location.find(".temp").removeClass("temp").removeClass("hidden");
	location.draggable("destroy").css({"left":"","top":""});
	$("#Title").show(); //only do this if it was actually shown before..
	});
	location.append(importWorld).append(blankSlate).append(done);
}

function newGame(){
	var setSeed = $("<div>").addClass("selectable").attr("id", "setSeed")
				.click(function(e){$(".seedSet").show();$(this).hide();}).text("Set Seed");
	var seedInput = $("<input></input>").addClass("selectable").addClass("seedSet").val(seed).attr("id", "seed").hide();
	var seedDiscard = $("<span>").hide().addClass("selectable").addClass("seedSet")
		.click( function(e){$("#seed").val(seed)}).text("Discard");
	var seedTime = $("<span>").hide().addClass("selectable").addClass("seedSet")
		.click( function(e){$("#seed").val("");seed = undefined;}).text("Use Time");
	var seedConfirm = $("<span>").hide().addClass("selectable").addClass("seedSet").text("Set Seed")
		.click( function(e){var t = $("#seed");seed = t.val();$(".seedSet").hide();$("#setSeed").show();});

	//var screensize = $("<div>").attr("id", "screensize").text("Change Screen Size").bind(click, function(e){if(resizeable){$(this).text("Change Screen Size");}else{$(this).text("Go ahead and resize it");}risezable=!resizeable;});
	var tilesizeInput = $("<input></input>").addClass("selectable").attr("id","tsinput").val(world.tileSize).hide().bind("keyup",function(e){
		if($(this).val().match(/[^0-9]/)){
			$(this).addClass("error");
		}
		else{
			$(this).removeClass("error");
		}
	//check if e is enter and no error. then set tilesize
	});
	var tilesize = $("<div>").addClass("selectable").attr("id", "tilesize").text("Change Tile Size").click( function(e){
		if($(this).attr("active") == "true"){
		 $(this).attr("active","false").text("Change Tile Size"); tileSize = $("#tsinput").hide().val();
		}
		else{
		 $(this).attr("active","true").text("Set Tile Size!"); $("#tsinput").val(tileSize).show();
		}
	});
	
	var regenerate = $("<div>").addClass("selectable").attr("id", "regenerate").text("Generate New World").click( function(e){craftNewWorld(tileSize,seed);});
	var edit = $("<div>").addClass("selectable").attr("id", "edit").text("Edit or Import World").click( function(e){editWorld($(this).parent());});
	var charGen = $("<div>").addClass("selectable").attr("id", "start").text("Accept World").click( function(e){characterGen();});
	var back = $("<div>").addClass("selectable").attr("id","back").text("Back To Menu").click( function(e){openInitMenu(false);});
	$("#NewGameMenu").empty().append(setSeed).append(seedInput).append(seedTime).append(seedConfirm).append(seedDiscard)
			.append(tilesizeInput).append(tilesize).append(regenerate).append(edit).append(charGen).append(back);
}

function loadJSFile(file){
	$("head").append($("<script>").attr("type","text/javascript").attr("src",file));
}

function selectMode(mode){
	if(mode != undefined){
		loadJSFile("scripts/" + mode);
		openInitMenu();
	}
	var header = $("<div>").text("Select Mode").css("text-align","left");
	//var bgImage1 = $("<image>").attr("id","bgImage1").css({"position":"absolute", "opacity":0.6, "top":0})
	//	.attr("src","scripts/res/colonization.jpg").hide();
	//var bgImage2 = $("<image>").attr("id","bgImage2").css({"position":"absolute", "opacity":0.6, "top":0})
	//	.attr("src","scripts/res/dynasty.jpg");
	//$("body").append(bgImage1).append(bgImage2);
	var colonization = $("<div>").addClass("selectable").text("Colonization").click( function(){mode = "colonization";loadJSFile("scripts/colonization.js"); openInitMenu();})
		.hover(function(){$("#bgImage1").show(); $("#bgImage2").hide();});
	var dynasty = $("<div>").addClass("selectable").text("Dynasty").click( function(){mode = "dynasty";//loadJSFile("scripts/dynasty.js"); 
		openInitMenu();})
		.hover(function(){$("#bgImage2").show(); $("#bgImage1").hide();});
	$("#NewGameMenu").empty().append(header).append(colonization).append(dynasty);
}

function init(){
		/*Runs at startup*/
	$(".window").hide();
	$("#Loading").hide();
	h = $(window).height();
	w = $(window).width();
	niceSeed = 1325628640985;
	m = new MersenneTwister(niceSeed);
	world = new World();
	$("#tileInfo").draggable().css("position","");
	$("#FamilyTree").hide();
		/*Platform specifics*/
	var ua = navigator.userAgent;
	iOSDevice = ua.match(/iPad|iPhone/i);
	
	if(iOSDevice){
		$("#NewGameMenu").css({"width":"33%","height":"60%"});
		$("#MenuHeaders").css("max-width","60%");
		$("#MenuDisplay").css("width","20%");
		$("#Title").css("height","28%");
	}
    uiClick = (iOSDevice) ? "touchstart" : "click";
	uiHover = (iOSDevice) ? "touchstart" : "mouseover";
	uiHoverEnd = (iOSDevice) ? "touchend" : "mouseout";
	uiDblClick = (iOSDevice) ? "double-tap" : "dblclick";
	world.tileSize = tileSize = (iOSDevice) ? 8 : 2;
	scale = world.tileSize;
	world.sizeX = 464;//Math.floor(w/world.tileSize);
	world.sizeY = 264; //Math.floor(h/world.tileSize);	
	
		/*Look a URL to see if parameters have been sent*/
	var showMap = true;
	var i = getUrlVar();
	if(i == "start"){
		craftNewWorld();
		newGame();
		characterGen();
		return start();
	}
	else if(i == "continue"){
		return continueGame();
	}
	else if(i == "debug"){
		debug = true;
	}
	else if(i == "simple"){
		showMap = false;
	}
	selectMode();
	//openInitMenu(showMap);	
}

function saveExists(){
	return false;
}

function start(){
	/*Starts the game*/
	/*All world generation should already be done by this point*/
	
	$(".init").hide();
	modeInit();
	var pos = world.dynasty.root.location;
	zoomInOn(world.tiles[pos.x][pos.y], 24);
	//fog = true;
	range = 20;
	//$("#Loading").show();
	keyBindings();
	//var t1, t2, t3;
	//t1 = new Date();
	
	maxHeight = -1;
	minHeight = 1;
	
	if(mode=="colonization"){
		$("#DynastyHeader").text("Colony");
	}
	//measureDepth(world,0,false);//,1,true);
	//checkAreas(world);
	//	measureDepth(world,2,true);
	//	generateRivers(world);
	//t3 = new Date();

	//fetchRandomName();
	//sessionStorage['world'] = worldToJSON(world);
	//drawWorld(world.sizeX, world.sizeY, 16);
	//t4 = new Date();
	//repaint2();
	//$('#newPlayer').svg();
	//drawWorld2($("#newPlayer").svg('get'),world.sizeX, world.sizeY, world.tileSize);
	//t5 = new Date();
	//$("svg").children().addClass("tile");
	filter = false;
	center = 250;
	//keyBindings();
	$(".window").show();
	$("#eventViewer").addClass("hidden");
	nrTiles = 0;
	//p = generatePerson("a", "Female");
	//displayPerson(p);
	types = {"water":0,"mountain":0,"forest":0,"grass":0,"sand":0};
	for(var x = 0; x < world.sizeX; x++){
		for(var y = 0;y < world.sizeY;y++){
			types[world.tiles[x][y].type]++;
			nrTiles++;
		}
	}
	updateDateHeader();
}

function updateLoading(){
	loadingDots++;
	if(loadingDots > 3){
		loadingDots = 1;
	}
	var dots = $("#loadingDots").empty();
	for(var i = 0; i < loadingDots; i++){
		dots.append(".");
	}
}

function startLoading(){
	$("#Loading").show();
	loading = true;
}
function stopLoading(){
	$("#Loading").hide();
	loading = false;
}

var loadingDots = 0;
var ticks = 0;
var loading = false;
var loadCounter = 0;
function tick(){
	var prevX = xScroll;
	var prevY = yScroll;
	xScroll += dx*scrollRate;
	yScroll += dy*scrollRate;
	if(xScroll > (world.sizeX*scale-w)) xScroll = (world.sizeX*scale-w);
	if(xScroll < 0) xScroll = 0;
	if(yScroll > (world.sizeY*scale-h)) yScroll = (world.sizeY*scale-h);
	if(yScroll < 0) yScroll = 0;
	if(//zoomState && 
	(prevX-xScroll != 0 || prevY-yScroll != 0)){
		repaint2();
	}
	ticks++;
	if(loading != undefined && loading){
		if(loadCounter == undefined || loadCounter % 300 == 0){
			updateLoading();
			loadCounter = 1;
		}
		loadCounter++;
	}
	setTimeout(tick,60/1000);
}

	/*
		Set world parameters (size, resolution, etc)
		Generate world
		measure areas, generate borders
		measure depth (mountains, lakes)
		generate height map
		generate rivers
		measure depth (grass, forest)
		place resources
		calculate values
		place population
	*/

$(document).ready(function() { //runs when site is ready.
    init();
	//tick();
	$(window).unload(function(event) {
		//save world into sessionStorage.
		//sessionStorage['world'] = worldToJSON(world);
    });
});
